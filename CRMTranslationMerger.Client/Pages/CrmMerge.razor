@page "/crm-merge"
@using System.Text.Json
@using CRMTranslationMerger.Client.Models
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>CRM Translation Merger</PageTitle>

<div class="container">
    <div class="header-section">
        <h1>üåç CRM Translation Merger</h1>
        <p class="subtitle">Automatically merge Excel translations into CRM JSON with Handlebars conversion</p>
    </div>

    <!-- Comprehensive Instructions -->
    <div class="instructions-panel">
        <div class="instructions-header">
            <h2>ÔøΩ Complete Guide</h2>
            <p>Follow these steps to merge your translations</p>
        </div>

        <div class="steps-grid">
            <div class="step-card">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3>üì• Export from Google Sheets</h3>
                    <ul>
                        <li>Open your Google Sheets translation document</li>
                        <li>Select all cells (Ctrl+A / Cmd+A)</li>
                        <li>Copy (Ctrl+C / Cmd+C)</li>
                        <li>Open Excel and paste (Ctrl+V / Cmd+V)</li>
                        <li>Save as .xlsx file</li>
                    </ul>
                </div>
            </div>

            <div class="step-card">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3>üìÑ Get CRM Template</h3>
                    <ul>
                        <li>Download the Content Docstore JSON template from your CRM</li>
                        <li>This file contains the structure: <code>contentDoc.content.localizedContents</code></li>
                        <li>Keep this file - you'll upload it in step 5</li>
                    </ul>
                </div>
            </div>

            <div class="step-card">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3>üîç Find Translation Keys</h3>
                    <ul>
                        <li>Open the CRM JSON template</li>
                        <li>Look inside <code>localizedContents</code> ‚Üí <code>en</code> (or first language)</li>
                        <li>Copy the key names, for example:</li>
                    </ul>
                    <div class="code-example">
                        "subject"<br/>
                        "messageReceived"<br/>
                        "replyNow"<br/>
                        "years"
                    </div>
                </div>
            </div>

            <div class="step-card">
                <div class="step-number">4</div>
                <div class="step-content">
                    <h3>‚úèÔ∏è Update Excel Keys</h3>
                    <ul>
                        <li>Open your Excel file from step 1</li>
                        <li>In the <strong>first column</strong>, replace your keys with the exact keys from the template</li>
                        <li>‚ö†Ô∏è Keys are <strong>case-sensitive</strong>: "Subject" ‚â† "subject"</li>
                        <li>Save the file</li>
                    </ul>
                </div>
            </div>

            <div class="step-card">
                <div class="step-number">5</div>
                <div class="step-content">
                    <h3>üì§ Upload Files</h3>
                    <ul>
                        <li>Upload the <strong>CRM JSON template</strong> (from step 2)</li>
                        <li>Upload the <strong>Excel file</strong> (from step 4)</li>
                        <li>Enable AI conversion to convert placeholders like:<br/>
                            <code>[Sender name]</code> ‚Üí <code>{{"{{"}}LoadedData.SenderProfile.Handle}}</code>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="step-card">
                <div class="step-number">6</div>
                <div class="step-content">
                    <h3>üöÄ Merge & Download</h3>
                    <ul>
                        <li>Click "Merge Translations"</li>
                        <li>Review the statistics</li>
                        <li>Download the merged JSON file</li>
                        <li>Upload to your CRM system</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="tips-section">
            <h3>üí° Pro Tips</h3>
            <div class="tips-grid">
                <div class="tip-item">
                    <span class="tip-icon">üìä</span>
                    <div>
                        <strong>Excel Format:</strong> Supports both matrix format (languages as columns) and standard format (LanguageCode, Key, Value columns)
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üîß</span>
                    <div>
                        <strong>Auto-Repair:</strong> The tool automatically fixes common issues like missing closing brackets in placeholders
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">üéØ</span>
                    <div>
                        <strong>Pattern Matching:</strong> The tool detects whether to use String.Append or String.Concat from your reference language (usually English)
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="upload-section">
        <h2>1Ô∏è‚É£ Upload Files</h2>
        <div class="file-inputs">
            <div class="file-input-group">
                <label for="jsonFile">üìÑ CRM JSON File (existing template):</label>
                <InputFile id="jsonFile" OnChange="@OnJsonFileSelected" accept=".json" />
                @if (!string.IsNullOrEmpty(jsonFileName))
                {
                    <span class="file-name">‚úì @jsonFileName</span>
                }
            </div>

            <div class="file-input-group">
                <label for="excelFile">
                    üìä Excel File (new translations):
                    <span class="tooltip-icon" title="Upload the Excel file with Google Sheets data. First column should match CRM template keys exactly!">‚ÑπÔ∏è</span>
                </label>
                <InputFile id="excelFile" OnChange="@OnExcelFileSelected" accept=".xlsx,.xls" />
                @if (!string.IsNullOrEmpty(excelFileName))
                {
                    <span class="file-name">‚úì @excelFileName</span>
                }
                <small style="color: #666; display: block; margin-top: 5px;">
                    Supports both formats:<br/>
                    ‚Ä¢ Matrix: Key column + language columns (UK, Bulgarian, etc.)<br/>
                    ‚Ä¢ Standard: LanguageCode, TranslationKey, Value
                </small>
            </div>
        </div>
    </div>

    <div class="options-section">
        <h2>2Ô∏è‚É£ Conversion Options</h2>
        
        <div class="conversion-mode-selector">
            <label class="mode-option @(conversionMode == "pattern" ? "selected" : "")" @onclick="@(() => conversionMode = "pattern")">
                <input type="radio" name="mode" checked="@(conversionMode == "pattern")" />
                <div class="mode-content">
                    <strong>üìê Pattern Only</strong>
                    <p>Fast & Free - Handles simple placeholders only</p>
                    <small>Best for: Basic replacements like [Sender name] ‚Üí {{"{{"}}LoadedData.SenderProfile.Handle{{"}}"}}</small>
                </div>
            </label>

            <label class="mode-option @(conversionMode == "ai" ? "selected" : "")" @onclick="@(() => conversionMode = "ai")">
                <input type="radio" name="mode" checked="@(conversionMode == "ai")" />
                <div class="mode-content">
                    <strong>ü§ñ AI-Powered</strong>
                    <p>Intelligent - Handles all edge cases</p>
                    <small>Best for: Complex scenarios with conditionals, loops, nested expressions</small>
                </div>
            </label>

            <label class="mode-option @(conversionMode == "hybrid" ? "selected" : "")" @onclick="@(() => conversionMode = "hybrid")">
                <input type="radio" name="mode" checked="@(conversionMode == "hybrid")" />
                <div class="mode-content">
                    <strong>‚ö° Smart Hybrid</strong>
                    <p>Auto-detect complexity and use best approach</p>
                    <small>Recommended: Uses pattern matching for simple cases, AI for complex ones</small>
                </div>
            </label>
        </div>

        <label class="checkbox-option">
            <input type="checkbox" @bind="showPreview" />
            Show conversion preview before final merge
        </label>
    </div>

    <div class="action-section">
        <button class="btn-primary" @onclick="MergeFiles" disabled="@(!CanMerge || isProcessing)">
            @if (isProcessing)
            {
                <span>‚è≥ Processing...</span>
            }
            else
            {
                <span>üöÄ Merge Translations</span>
            }
        </button>
    </div>

    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div class="@(hasError ? "alert-error" : "alert-success")">
            @statusMessage
        </div>
    }

    @if (mergeStats != null)
    {
        <div class="results-section">
            <h2>‚úÖ Merge Complete!</h2>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Languages:</span>
                    <span class="stat-value">@mergeStats.Languages</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Translation Keys:</span>
                    <span class="stat-value">@mergeStats.TotalKeys</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Added:</span>
                    <span class="stat-value added">+@mergeStats.Added</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Updated:</span>
                    <span class="stat-value updated">‚Üª@mergeStats.Updated</span>
                </div>
            </div>

            <button class="btn-secondary" @onclick="DownloadResult">
                üíæ Download Merged JSON
            </button>
        </div>
    }
</div>

@code {
    private string? jsonFileName;
    private string? excelFileName;
    private string? jsonContent;
    private string? excelDataJson;
    private string conversionMode = "hybrid"; // "pattern", "ai", or "hybrid"
    private string? apiKey;
    private string aiProvider = "openai"; // "openai" or "azure"
    private string aiModel = "gpt-4o-mini";
    private string? azureEndpoint;
    private bool showPreview = false;
    private bool isProcessing = false;
    private string? statusMessage;
    private bool hasError = false;
    private MergeStats? mergeStats;
    private string? mergedJsonResult;
    
    // Column name mappings (auto-detected from Excel)
    private string? languageColumn;
    private string? keyColumn;
    private string? valueColumn;

    private bool CanMerge => !string.IsNullOrEmpty(jsonContent) && 
                             !string.IsNullOrEmpty(excelDataJson);

    private class MergeStats
    {
        public int Languages { get; set; }
        public int TotalKeys { get; set; }
        public int Added { get; set; }
        public int Updated { get; set; }
    }

    private async Task OnJsonFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            jsonFileName = file.Name;

            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
            using var reader = new StreamReader(stream);
            jsonContent = await reader.ReadToEndAsync();

            // Validate it's valid JSON (but don't enforce structure - AI can handle any format)
            JsonDocument.Parse(jsonContent); // Just check if it's valid JSON

            statusMessage = $"‚úì CRM JSON file loaded: {jsonFileName}";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Error loading JSON: {ex.Message}";
            hasError = true;
            jsonContent = null;
            jsonFileName = null;
        }
    }

    private async Task OnExcelFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            excelFileName = file.Name;

            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var fileBytes = memoryStream.ToArray();
            var base64 = Convert.ToBase64String(fileBytes);

            // Parse Excel via JavaScript
            excelDataJson = await JS.InvokeAsync<string>("excelInterop.parseExcel", base64);

            // Validate structure
            var excelData = JsonSerializer.Deserialize<List<Dictionary<string, string>>>(excelDataJson);
            if (excelData == null || excelData.Count == 0)
            {
                throw new Exception("No data found in Excel");
            }

            var firstRow = excelData[0];
            var columns = firstRow.Keys.ToList();
            
            // Check if this is a MATRIX format (Key column + multiple language columns)
            // Matrix format: __EMPTY/Key column + UK/Bulgarian/Czech/etc. columns
            var possibleKeyColumns = new[] { "__EMPTY", "Key", "TranslationKey", "Name", "Field" };
            var keyColumnName = columns.FirstOrDefault(c => possibleKeyColumns.Contains(c, StringComparer.OrdinalIgnoreCase));
            
            if (keyColumnName != null && columns.Count > 1)
            {
                // MATRIX FORMAT: First column is keys, rest are languages
                statusMessage = $"‚úì Excel parsed (Matrix format): {excelFileName} ({excelData.Count} rows, {columns.Count - 1} languages)";
                hasError = false;
                languageColumn = null; // Not used in matrix format
                keyColumn = keyColumnName;
                valueColumn = null; // Not used in matrix format
                return;
            }
            
            // STANDARD FORMAT: LanguageCode, TranslationKey, Value columns
            // Auto-detect column names (flexible matching)
            languageColumn = DetectColumn(columns, new[] { "LanguageCode", "Language", "Lang", "Locale", "Culture", "CultureCode" });
            keyColumn = DetectColumn(columns, new[] { "TranslationKey", "Key", "Name", "Field", "Property" });
            valueColumn = DetectColumn(columns, new[] { "Value", "Translation", "Text", "Content", "Message" });
            
            if (languageColumn == null || keyColumn == null || valueColumn == null)
            {
                var available = string.Join(", ", columns);
                throw new Exception($"Could not detect required columns. Available columns: {available}. " +
                    $"Expected columns like: LanguageCode/Language, TranslationKey/Key, Value/Translation");
            }
            
            statusMessage = $"‚úì Excel parsed: {excelFileName} ({excelData.Count} rows) - Detected columns: {languageColumn}, {keyColumn}, {valueColumn}";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Error parsing Excel: {ex.Message}";
            hasError = true;
            excelDataJson = null;
            excelFileName = null;
        }
    }

    private async Task MergeFiles()
    {
        if (!CanMerge) return;

        isProcessing = true;
        statusMessage = "üîÑ Merging translations...";
        hasError = false;
        mergeStats = null;

        try
        {
            // Parse CRM JSON
            // Try to parse as CrmDocument structure, but be flexible
            CrmDocument? crmDoc = null;
            Dictionary<string, Dictionary<string, string>>? localizedContents = null;
            
            try
            {
                crmDoc = JsonSerializer.Deserialize<CrmDocument>(jsonContent!);
                localizedContents = crmDoc?.ContentDoc?.Content?.LocalizedContents;
            }
            catch
            {
                // If structure doesn't match, create a new one
                localizedContents = new Dictionary<string, Dictionary<string, string>>();
            }
            
            // If no valid structure found, initialize empty
            if (localizedContents == null)
            {
                localizedContents = new Dictionary<string, Dictionary<string, string>>();
                statusMessage = "‚ÑπÔ∏è JSON doesn't match CRM structure - creating new localizedContents structure";
            }

            // Parse Excel data
            var excelData = JsonSerializer.Deserialize<List<Dictionary<string, string>>>(excelDataJson!);
            if (excelData == null)
            {
                throw new Exception("Failed to parse Excel data");
            }

            var addedCount = 0;
            var updatedCount = 0;
            var languagesSet = new HashSet<string>(localizedContents.Keys);

            // Check format: Matrix vs Standard
            bool isMatrixFormat = languageColumn == null && keyColumn != null;

            if (isMatrixFormat)
            {
                // MATRIX FORMAT: Each row has a key, and each column (except key column) is a language
                var firstRow = excelData[0];
                var languageColumns = firstRow.Keys.Where(k => k != keyColumn).ToList();
                
                // Map Excel language names to CRM language codes
                var languageMapping = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
                {
                    { "UK", "en" },
                    { "English", "en" },
                    { "Bulgarian", "bg-BG" },
                    { "Czech", "cs-CZ" },
                    { "Danish", "da-DK" },
                    { "Spanish", "es-ES" },
                    { "Finnish", "fi-FI" },
                    { "French", "fr-FR" },
                    { "Hungarian", "hu-HU" },
                    { "Italian", "it-IT" },
                    { "Dutch", "nl-BE" },
                    { "Norwegian", "nb-NO" },
                    { "Polish", "pl-PL" },
                    { "Portuguese", "pt-PT" },
                    { "Romanian", "ro-RO" },
                    { "Slovak", "sk-SK" },
                    { "Swedish", "sv-SE" }
                };

                foreach (var row in excelData)
                {
                    var translationKey = row[keyColumn!];
                    if (string.IsNullOrWhiteSpace(translationKey)) continue;

                    foreach (var langCol in languageColumns)
                    {
                        var value = row.GetValueOrDefault(langCol, "");
                        if (string.IsNullOrWhiteSpace(value)) continue;

                        // Map Excel language name to CRM code
                        var langCode = languageMapping.GetValueOrDefault(langCol, langCol.ToLower());

                        // Ensure language exists in CRM
                        if (!localizedContents.ContainsKey(langCode))
                        {
                            localizedContents[langCode] = new Dictionary<string, string>();
                            languagesSet.Add(langCode);
                        }

                        var langDict = localizedContents[langCode];

                        // NO AI CONVERSION HERE - we'll do batch later
                        // Just store the original value
                        if (langDict.ContainsKey(translationKey))
                        {
                            langDict[translationKey] = value;
                            updatedCount++;
                        }
                        else
                        {
                            langDict[translationKey] = value;
                            addedCount++;
                        }
                    }
                }
                
                // BATCH AI CONVERSION: Convert ALL texts at once (ENTERPRISE APPROACH)
                if (conversionMode != "pattern" || true) // Always convert for consistency
                {
                    try
                    {
                        // Collect all texts from localizedContents
                        var textsToConvert = new Dictionary<string, string>();
                        foreach (var (langCode, langDict) in localizedContents)
                        {
                            foreach (var (key, value) in langDict)
                            {
                                var cellKey = $"{langCode}|{key}";
                                textsToConvert[cellKey] = value;
                            }
                        }
                        
                        Console.WriteLine($"üöÄ Batch converting {textsToConvert.Count} texts...");
                        var convertedTexts = await ConvertBatchWithAi(textsToConvert);
                        Console.WriteLine($"‚úÖ Batch conversion complete!");

                        // Apply converted texts back
                        foreach (var (cellKey, convertedText) in convertedTexts)
                        {
                            var parts = cellKey.Split('|');
                            if (parts.Length == 2)
                            {
                                var langCode = parts[0];
                                var key = parts[1];
                                if (localizedContents.ContainsKey(langCode))
                                {
                                    localizedContents[langCode][key] = convertedText;
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"‚ùå Batch AI conversion failed: {ex.Message}. Using original values.");
                    }
                }
            }
            else
            {
                // STANDARD FORMAT: LanguageCode, TranslationKey, Value columns
                // Group Excel data by language (using detected column name)
                var excelByLanguage = excelData
                    .GroupBy(row => row[languageColumn!])
                    .ToDictionary(g => g.Key, g => g.ToList());

                // Process each language from Excel
                foreach (var (langCode, rows) in excelByLanguage)
                {
                    // Ensure language exists in CRM
                    if (!localizedContents.ContainsKey(langCode))
                    {
                        localizedContents[langCode] = new Dictionary<string, string>();
                        languagesSet.Add(langCode);
                    }

                    var langDict = localizedContents[langCode];

                    // Process each translation key (using detected column names)
                    foreach (var row in rows)
                    {
                        var key = row[keyColumn!];
                        var value = row[valueColumn!];

                        // Note: Standard format conversion happens later in batch
                        // Just store original values for now

                        // Add or update
                        if (langDict.ContainsKey(key))
                        {
                            langDict[key] = value;
                            updatedCount++;
                        }
                        else
                        {
                            langDict[key] = value;
                            addedCount++;
                        }
                    }
                }
                
                // BATCH AI CONVERSION for standard format as well
                try
                {
                    // Collect all texts from localizedContents
                    var textsToConvert = new Dictionary<string, string>();
                    foreach (var (langCode, langDict) in localizedContents)
                    {
                        foreach (var (key, value) in langDict)
                        {
                            var cellKey = $"{langCode}|{key}";
                            textsToConvert[cellKey] = value;
                        }
                    }
                    
                    Console.WriteLine($"üöÄ Batch converting {textsToConvert.Count} texts (standard format)...");
                    var convertedTexts = await ConvertBatchWithAi(textsToConvert);
                    Console.WriteLine($"‚úÖ Batch conversion complete!");

                    // Apply converted texts back
                    foreach (var (cellKey, convertedText) in convertedTexts)
                    {
                        var parts = cellKey.Split('|');
                        if (parts.Length == 2)
                        {
                            var langCode = parts[0];
                            var key = parts[1];
                            if (localizedContents.ContainsKey(langCode))
                            {
                                localizedContents[langCode][key] = convertedText;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"‚ùå Batch AI conversion failed: {ex.Message}. Using original values.");
                }
            }

            // Calculate total keys across all languages
            var totalKeys = localizedContents.Values.Sum(dict => dict.Count);

            // Generate result JSON
            var options = new JsonSerializerOptions 
            { 
                WriteIndented = true,
                Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
            };
            
            // If we had a valid CrmDocument structure, use it; otherwise create a new one
            if (crmDoc?.ContentDoc?.Content != null)
            {
                mergedJsonResult = JsonSerializer.Serialize(crmDoc, options);
            }
            else
            {
                // Create new CRM structure with the merged translations
                var newCrmDoc = new CrmDocument
                {
                    ContentDoc = new ContentDocWrapper
                    {
                        Content = new ContentData
                        {
                            LocalizedContents = localizedContents
                        }
                    }
                };
                mergedJsonResult = JsonSerializer.Serialize(newCrmDoc, options);
            }

            mergeStats = new MergeStats
            {
                Languages = languagesSet.Count,
                TotalKeys = totalKeys,
                Added = addedCount,
                Updated = updatedCount
            };

            statusMessage = $"‚úÖ Successfully merged {addedCount + updatedCount} translations across {languagesSet.Count} languages!";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Merge failed: {ex.Message}";
            hasError = true;
            mergeStats = null;
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task<string> ConvertWithAi(string text, Dictionary<string, Dictionary<string, string>> existingTranslations)
    {
        try
        {
            // Get sample of existing translations for context
            var sampleTranslations = existingTranslations
                .SelectMany(kvp => kvp.Value.Take(3))
                .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

            var request = new AiRequest
            {
                Text = text,
                JsonContext = sampleTranslations,
                ExcelContext = new { OriginalText = text }
            };

            var response = await Http.PostAsJsonAsync("/api/convert-placeholder", request);
            var result = await response.Content.ReadFromJsonAsync<AiResponse>();

            if (result?.Success == true && !string.IsNullOrEmpty(result.ConvertedText))
            {
                return result.ConvertedText;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"AI conversion failed: {ex.Message}");
        }

        return text;
    }

    private string? DetectColumn(List<string> columns, string[] possibleNames)
    {
        // Try exact match first (case-insensitive)
        foreach (var name in possibleNames)
        {
            var match = columns.FirstOrDefault(c => c.Equals(name, StringComparison.OrdinalIgnoreCase));
            if (match != null) return match;
        }
        
        // Try partial match
        foreach (var name in possibleNames)
        {
            var match = columns.FirstOrDefault(c => c.Contains(name, StringComparison.OrdinalIgnoreCase));
            if (match != null) return match;
        }
        
        return null;
    }

    private async Task<Dictionary<string, string>> ConvertBatchWithAi(Dictionary<string, string> texts)
    {
        try
        {
            Console.WriteLine($"üöÄ Starting conversion of {texts.Count} texts using {conversionMode} mode...");
            
            if (conversionMode == "pattern")
            {
                // Pure client-side pattern matching
                Console.WriteLine("üìê Using client-side pattern matching (fast & free)");
                var converter = new Services.PlaceholderConverter();
                var result = converter.ConvertBatch(texts);
                Console.WriteLine($"‚úÖ Pattern matching complete!");
                return result;
            }
            else
            {
                // Use server API for AI-powered or hybrid conversion
                Console.WriteLine($"ü§ñ Calling server API for {conversionMode} conversion...");
                
                var requestBody = new
                {
                    Texts = texts,
                    Mode = conversionMode,
                    ApiKey = apiKey,
                    Endpoint = aiProvider == "azure" ? azureEndpoint : null,
                    Model = aiProvider == "openai" ? aiModel : null,
                    JsonContext = jsonContent, // Send full JSON so AI can learn patterns
                    ExcelContext = excelDataJson // Send Excel data for context
                };
                
                var json = JsonSerializer.Serialize(requestBody);
                var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");
                
                var response = await Http.PostAsync("/api/convert-batch", content);
                
                if (!response.IsSuccessStatusCode)
                {
                    var error = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"‚ùå Server API error: {error}");
                    Console.WriteLine("‚ö†Ô∏è Falling back to client-side pattern matching");
                    
                    // Fallback to pattern matching
                    var converter = new Services.PlaceholderConverter();
                    return converter.ConvertBatch(texts);
                }
                
                var responseJson = await response.Content.ReadAsStringAsync();
                var result = JsonSerializer.Deserialize<Dictionary<string, string>>(responseJson);
                
                Console.WriteLine($"‚úÖ Server conversion complete!");
                return result ?? texts;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Conversion error: {ex.Message}");
            Console.WriteLine("‚ö†Ô∏è Falling back to original texts");
            return texts; // Return originals on error
        }
    }

    private async Task DownloadResult()
    {
        if (string.IsNullOrEmpty(mergedJsonResult)) return;

        var fileName = $"merged-crm-{DateTime.Now:yyyyMMdd-HHmmss}.json";
        var bytes = System.Text.Encoding.UTF8.GetBytes(mergedJsonResult);
        var base64 = Convert.ToBase64String(bytes);

        await JS.InvokeVoidAsync("excelInterop.downloadFile", fileName, base64);
    }
}
