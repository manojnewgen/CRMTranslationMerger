@page "/merge"
@using CRMTranslationMerger.Shared.Models
@using System.Text.Json
@inject HttpClient Http
@inject IJSRuntime JS

<PageTitle>CRM Translation Merger</PageTitle>

<div class="container">
    <h1>üåç CRM Translation Merger</h1>
    <p>Merge Excel translations into JSON using AI-powered Handlebars conversion</p>

    <div class="upload-section">
        <h2>1Ô∏è‚É£ Upload Files</h2>
        <div class="file-inputs">
            <div class="file-input-group">
                <label for="jsonFile">üìÑ JSON File (existing translations):</label>
                <InputFile id="jsonFile" OnChange="@OnJsonFileSelected" accept=".json" />
                @if (!string.IsNullOrEmpty(jsonFileName))
                {
                    <span class="file-name">‚úì @jsonFileName</span>
                }
            </div>

            <div class="file-input-group">
                <label for="excelFile">üìä Excel File (new translations):</label>
                <InputFile id="excelFile" OnChange="@OnExcelFileSelected" accept=".xlsx,.xls" />
                @if (!string.IsNullOrEmpty(excelFileName))
                {
                    <span class="file-name">‚úì @excelFileName</span>
                }
            </div>
        </div>
    </div>

    <div class="options-section">
        <h2>2Ô∏è‚É£ Options</h2>
        <label>
            <input type="checkbox" @bind="useAiConversion" />
            Use AI to convert Excel placeholders to Handlebars
        </label>
    </div>

    <div class="action-section">
        <button class="btn-primary" @onclick="MergeFiles" disabled="@(!CanMerge || isProcessing)">
            @if (isProcessing)
            {
                <span>‚è≥ Processing...</span>
            }
            else
            {
                <span>üöÄ Merge Translations</span>
            }
        </button>
    </div>

    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div class="@(hasError ? "alert-error" : "alert-success")">
            @statusMessage
        </div>
    }

    @if (mergeResult != null && mergeResult.Success)
    {
        <div class="results-section">
            <h2>‚úÖ Merge Complete!</h2>
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Total Translations:</span>
                    <span class="stat-value">@mergeResult.TotalTranslations</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Added:</span>
                    <span class="stat-value added">+@mergeResult.AddedTranslations</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Updated:</span>
                    <span class="stat-value updated">‚Üª@mergeResult.UpdatedTranslations</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Languages:</span>
                    <span class="stat-value">@string.Join(", ", mergeResult.Languages)</span>
                </div>
            </div>

            <button class="btn-secondary" @onclick="DownloadResult">
                üíæ Download Merged JSON
            </button>
        </div>
    }
</div>

@code {
    private string? jsonFileName;
    private string? excelFileName;
    private string? jsonContent;
    private string? excelDataJson;
    private bool useAiConversion = true;
    private bool isProcessing = false;
    private string? statusMessage;
    private bool hasError = false;
    private MergeResult? mergeResult;

    private bool CanMerge => !string.IsNullOrEmpty(jsonContent) && !string.IsNullOrEmpty(excelDataJson);

    private async Task OnJsonFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            jsonFileName = file.Name;

            using var stream = file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024); // 5MB limit
            using var reader = new StreamReader(stream);
            jsonContent = await reader.ReadToEndAsync();

            // Validate JSON
            JsonDocument.Parse(jsonContent);
            statusMessage = $"‚úì JSON file loaded: {jsonFileName}";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Error loading JSON: {ex.Message}";
            hasError = true;
            jsonContent = null;
            jsonFileName = null;
        }
    }

    private async Task OnExcelFileSelected(InputFileChangeEventArgs e)
    {
        try
        {
            var file = e.File;
            excelFileName = file.Name;

            // Read file as base64 for JS interop
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
            using var memoryStream = new MemoryStream();
            await stream.CopyToAsync(memoryStream);
            var fileBytes = memoryStream.ToArray();
            var base64 = Convert.ToBase64String(fileBytes);

            // Parse Excel via JavaScript (SheetJS)
            excelDataJson = await JS.InvokeAsync<string>("excelInterop.parseExcel", base64);

            statusMessage = $"‚úì Excel file parsed: {excelFileName}";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Error parsing Excel: {ex.Message}";
            hasError = true;
            excelDataJson = null;
            excelFileName = null;
        }
    }

    private async Task MergeFiles()
    {
        if (!CanMerge) return;

        isProcessing = true;
        statusMessage = "üîÑ Merging translations...";
        hasError = false;
        mergeResult = null;

        try
        {
            // Parse JSON and Excel data
            var jsonDoc = JsonDocument.Parse(jsonContent!);
            var excelData = JsonSerializer.Deserialize<List<Dictionary<string, string>>>(excelDataJson!);

            if (excelData == null || excelData.Count == 0)
            {
                throw new Exception("No data found in Excel file");
            }

            // Get existing localizedContents
            var contentDoc = JsonSerializer.Deserialize<ContentDoc>(jsonContent!);
            if (contentDoc == null)
            {
                throw new Exception("Invalid JSON structure");
            }

            var existingContents = contentDoc.Content.LocalizedContents;
            var addedCount = 0;
            var updatedCount = 0;
            var languages = new HashSet<string>();

            // Process each row from Excel
            foreach (var row in excelData)
            {
                if (!row.ContainsKey("CultureCode") || !row.ContainsKey("Content"))
                    continue;

                var cultureCode = row["CultureCode"];
                var content = row["Content"];

                languages.Add(cultureCode);

                // Convert placeholders using AI if enabled
                if (useAiConversion)
                {
                    content = await ConvertPlaceholdersWithAi(content, existingContents, row);
                }

                // Find existing or add new
                var existing = existingContents.FirstOrDefault(lc => lc.CultureCode == cultureCode);
                if (existing != null)
                {
                    existing.Content = content;
                    updatedCount++;
                }
                else
                {
                    existingContents.Add(new LocalizedContent { CultureCode = cultureCode, Content = content });
                    addedCount++;
                }
            }

            // Generate result JSON
            var options = new JsonSerializerOptions { WriteIndented = true };
            var mergedJson = JsonSerializer.Serialize(contentDoc, options);

            mergeResult = new MergeResult
            {
                Success = true,
                MergedJson = mergedJson,
                TotalTranslations = existingContents.Count,
                AddedTranslations = addedCount,
                UpdatedTranslations = updatedCount,
                Languages = languages.ToList()
            };

            statusMessage = $"‚úÖ Successfully merged {addedCount + updatedCount} translations!";
            hasError = false;
        }
        catch (Exception ex)
        {
            statusMessage = $"‚ùå Merge failed: {ex.Message}";
            hasError = true;
            mergeResult = null;
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task<string> ConvertPlaceholdersWithAi(string content, List<LocalizedContent> existingContents, Dictionary<string, string> excelRow)
    {
        try
        {
            var request = new AiRequest
            {
                Text = content,
                JsonContext = existingContents.Take(3).ToList(), // Sample of existing patterns
                ExcelContext = excelRow
            };

            var response = await Http.PostAsJsonAsync("/api/convert-placeholder", request);
            var result = await response.Content.ReadFromJsonAsync<AiResponse>();

            if (result?.Success == true && !string.IsNullOrEmpty(result.ConvertedText))
            {
                return result.ConvertedText;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"AI conversion failed: {ex.Message}");
        }

        return content; // Return original if AI fails
    }

    private async Task DownloadResult()
    {
        if (mergeResult?.MergedJson == null) return;

        var fileName = $"merged-translations-{DateTime.Now:yyyyMMdd-HHmmss}.json";
        var bytes = System.Text.Encoding.UTF8.GetBytes(mergeResult.MergedJson);
        var base64 = Convert.ToBase64String(bytes);

        await JS.InvokeVoidAsync("excelInterop.downloadFile", fileName, base64);
    }
}
